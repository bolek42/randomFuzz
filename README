TODO:
    report + update logic

strategy:
    1. Mutate Testcase randomly
    2. Merge Testcases

    3. Maximum Coverage?



fuzzer definition:
    execute testcase callback
        fix input (e.g. png_fix)
        call stuff

        def start_watchdog( pid, files[]):

        returns popen object

        "regions" for independent fuzzing

    new testcase callback

    initial mutations

    files for deployment
        relative from work dir
        
    work dir
    (additional seeds)


controller:
    keeps track of bitsets
    collect updates from worker
    updates worker
        new testcases
        bitset updates
        crash_addr

    should not know testcase structure

    displays summary
        testcase rate
    does not execute anything


worker:
    executes testcase
    notifies server
    generates random testcases
    crash detection

mutator:
    save actual value for insert/replace
    add+insert
    add+dup
    regions
        independent fuzzing and mutation states
        described by name
        individual configurable
            set of mutations


network api
    s -> c
        provision
            callbacks
            files
            seeds
            initial testcases

    request once a second
    s -> c
        testcase_update #dict of tid: testcase
        bitset_update #dict of s:biset
        crash_update #array of crash addresses

    c -> s
        testcases
            testcases + bitsets
        crash reports
        rate for worker


problems:
    ssl
        separate mutation state for each packet
        merging?

    initial mutations?
    24 bit int

